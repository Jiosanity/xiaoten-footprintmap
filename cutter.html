<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜çº§è¡¨æƒ…åŒ…ç½‘æ ¼è£å‰ªå·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --panel-w: 300px; }
        body { margin: 0; padding: 0; font-family: sans-serif; background: var(--bg); display: flex; height: 100vh; overflow: hidden; }
        
        /* å·¦ä¾§æ§åˆ¶æ  */
        .sidebar {
            width: var(--panel-w); background: white; padding: 20px; box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; gap: 15px; z-index: 10; overflow-y: auto;
        }
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #333; }
        .control-group { border-bottom: 1px solid #eee; padding-bottom: 15px; }
        label { display: block; font-size: 12px; color: #666; margin-bottom: 5px; font-weight: bold; }
        input[type="number"], button { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        .row-col-inputs { display: flex; gap: 10px; }
        
        .btn-primary { background: var(--primary); color: white; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn-primary:hover { background: #1d4ed8; }
        .btn-outline { background: transparent; border: 1px solid var(--primary); color: var(--primary); cursor: pointer; }

        /* å³ä¾§å·¥ä½œåŒº */
        .workspace {
            flex: 1; position: relative; display: flex; align-items: center; justify-content: center;
            background-color: #e5e5e5;
            background-image: radial-gradient(#ccc 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto;
            user-select: none;
        }

        /* å›¾ç‰‡å®¹å™¨ */
        #imgContainer { position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.2); line-height: 0; }
        #sourceImg { max-width: 80vw; max-height: 90vh; display: block; pointer-events: none; }

        /* è£å‰ªæ¡† (æ ¸å¿ƒç»„ä»¶) */
        #cropBox {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border: 2px solid rgba(255, 0, 0, 0.8);
            box-sizing: border-box;
            cursor: move;
            /* å†…éƒ¨ç½‘æ ¼çº¿ */
            background: linear-gradient(to right, rgba(0,255,255,0.5) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(0,255,255,0.5) 1px, transparent 1px);
            z-index: 5;
        }
        
        /* è£å‰ªæ¡†çš„æ‹–æ‹½æ‰‹æŸ„ */
        .handle {
            width: 10px; height: 10px; background: white; border: 1px solid #333;
            position: absolute; z-index: 6;
        }
        .nw { top: -6px; left: -6px; cursor: nw-resize; }
        .ne { top: -6px; right: -6px; cursor: ne-resize; }
        .sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .se { bottom: -6px; right: -6px; cursor: se-resize; }

        /* é®ç½©å±‚ (è®©éé€‰åŒºå˜æš—) */
        #overlayMask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); pointer-events: none;
            clip-path: polygon(0% 0%, 0% 100%, 0 100%, 0 0, 100% 0, 100% 100%, 0 100%, 0 100%, 100% 100%, 100% 0%);
        }

        #statusInfo { font-size: 12px; color: #666; margin-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>

<div class="sidebar">
    <h2>ğŸ§© è¡¨æƒ…åŒ…ç½‘æ ¼åˆ‡å›¾</h2>
    
    <div class="control-group">
        <label>1. ä¸Šä¼ å›¾ç‰‡</label>
        <input type="file" id="fileInput" accept="image/*">
    </div>

    <div class="control-group">
        <label>2. è®¾ç½®ç½‘æ ¼ (åˆ— x è¡Œ)</label>
        <div class="row-col-inputs">
            <input type="number" id="colsInput" value="7" min="1" placeholder="åˆ—">
            <span style="padding-top:8px">x</span>
            <input type="number" id="rowsInput" value="4" min="1" placeholder="è¡Œ">
        </div>
        <button class="btn-outline" id="resetBoxBtn" style="margin-top:10px; font-size:12px">é‡ç½®é€‰åŒºåˆ°å…¨å›¾</button>
    </div>

    <div class="control-group">
        <label>3. å¯¼å‡ºé€‰é¡¹ (å¯é€‰)</label>
        <div style="font-size:12px; margin-bottom:5px;">
            <input type="checkbox" id="resizeCheck"> å¼ºåˆ¶è°ƒæ•´æ¯ä¸ªåˆ‡ç‰‡å¤§å°
        </div>
        <div id="resizeOptions" style="display:none; gap:5px;">
            <input type="number" id="targetW" placeholder="å®½ (px)" value="200">
            <input type="number" id="targetH" placeholder="é«˜ (px)" value="200">
        </div>
    </div>

    <div class="control-group" style="border:none;">
        <button id="downloadBtn" class="btn-primary" disabled>è£å‰ªå¹¶æ‰“åŒ…ä¸‹è½½</button>
        <div id="statusInfo">è¯·å…ˆä¸Šä¼ å›¾ç‰‡...</div>
    </div>
</div>

<div class="workspace" id="workspace">
    <div id="imgContainer" style="display:none;">
        <img id="sourceImg" src="">
        <div id="overlayMask"></div> <div id="cropBox">
            <div class="handle nw" data-dir="nw"></div>
            <div class="handle ne" data-dir="ne"></div>
            <div class="handle sw" data-dir="sw"></div>
            <div class="handle se" data-dir="se"></div>
        </div>
    </div>
</div>

<script>
    // å…ƒç´ è·å–
    const fileInput = document.getElementById('fileInput');
    const sourceImg = document.getElementById('sourceImg');
    const imgContainer = document.getElementById('imgContainer');
    const cropBox = document.getElementById('cropBox');
    const overlayMask = document.getElementById('overlayMask');
    const workspace = document.getElementById('workspace');
    
    const colsInput = document.getElementById('colsInput');
    const rowsInput = document.getElementById('rowsInput');
    const resetBoxBtn = document.getElementById('resetBoxBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusInfo = document.getElementById('statusInfo');
    
    const resizeCheck = document.getElementById('resizeCheck');
    const resizeOptions = document.getElementById('resizeOptions');

    // çŠ¶æ€å˜é‡
    let naturalW = 0, naturalH = 0;
    let currentScale = 1; // å±å¹•æ˜¾ç¤ºå°ºå¯¸ / åŸå§‹å°ºå¯¸
    let isDragging = false;
    let isResizing = false;
    let resizeDir = '';
    let startX, startY;
    let startLeft, startTop, startW, startH;

    // 1. åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
    resizeCheck.addEventListener('change', (e) => {
        resizeOptions.style.display = e.target.checked ? 'flex' : 'none';
    });

    colsInput.addEventListener('input', updateGridLines);
    rowsInput.addEventListener('input', updateGridLines);

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            sourceImg.src = event.target.result;
            sourceImg.onload = () => {
                naturalW = sourceImg.naturalWidth;
                naturalH = sourceImg.naturalHeight;
                imgContainer.style.display = 'block';
                downloadBtn.disabled = false;
                
                // é‡ç½®é€‰åŒº
                resetCropBox();
                updateStatus();
            };
        };
        reader.readAsDataURL(file);
    });

    resetBoxBtn.addEventListener('click', resetCropBox);

    function resetCropBox() {
        if (!naturalW) return;
        // è¿™é‡Œçš„ style è®¾ç½®çš„æ˜¯ç™¾åˆ†æ¯”ï¼Œç›¸å¯¹äº imgContainer
        cropBox.style.left = '0px';
        cropBox.style.top = '0px';
        cropBox.style.width = '100%';
        cropBox.style.height = '100%';
        updateGridLines();
        updateMask();
    }

    // æ›´æ–°ç½‘æ ¼çº¿çš„ CSS
    function updateGridLines() {
        const cols = parseInt(colsInput.value) || 1;
        const rows = parseInt(rowsInput.value) || 1;
        // åˆ©ç”¨ background-size æ¨¡æ‹Ÿç½‘æ ¼
        cropBox.style.backgroundSize = `${100/cols}% ${100/rows}%`;
        updateStatus();
    }

    function updateStatus() {
        if(!naturalW) return;
        // è®¡ç®—å½“å‰é€‰åŒºå¯¹åº”çš„çœŸå®åƒç´ å¤§å°
        const rect = getCropRectNatural();
        const cols = parseInt(colsInput.value) || 1;
        const rows = parseInt(rowsInput.value) || 1;
        
        const cellW = Math.floor(rect.w / cols);
        const cellH = Math.floor(rect.h / rows);
        
        statusInfo.innerHTML = `
            <strong>åŸå§‹å°ºå¯¸:</strong> ${naturalW}x${naturalH}<br>
            <strong>é€‰åŒºå°ºå¯¸:</strong> ${Math.round(rect.w)}x${Math.round(rect.h)}<br>
            <strong>å•å›¾å°ºå¯¸:</strong> ${cellW}x${cellH}<br>
            æ‹–æ‹½çº¢æ¡†è°ƒæ•´ä½ç½®ï¼Œæ‹–æ‹½å››ä¸ªè§’è°ƒæ•´å¤§å°ã€‚
        `;
    }

    // 2. æ ¸å¿ƒäº¤äº’é€»è¾‘ (æ‹–æ‹½ä¸ç¼©æ”¾)
    
    // é¼ æ ‡åœ¨ cropBox ä¸ŠæŒ‰ä¸‹
    cropBox.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('handle')) {
            isResizing = true;
            resizeDir = e.target.dataset.dir;
        } else {
            isDragging = true;
        }
        
        // è®°å½•åˆå§‹çŠ¶æ€
        startX = e.clientX;
        startY = e.clientY;
        startLeft = cropBox.offsetLeft;
        startTop = cropBox.offsetTop;
        startW = cropBox.offsetWidth;
        startH = cropBox.offsetHeight;

        e.preventDefault(); // é˜²æ­¢é€‰ä¸­æ–‡å­—
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging && !isResizing) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const containerW = imgContainer.offsetWidth;
        const containerH = imgContainer.offsetHeight;

        if (isDragging) {
            let newL = startLeft + dx;
            let newT = startTop + dy;

            // è¾¹ç•Œæ£€æŸ¥
            newL = Math.max(0, Math.min(newL, containerW - startW));
            newT = Math.max(0, Math.min(newT, containerH - startH));

            cropBox.style.left = newL + 'px';
            cropBox.style.top = newT + 'px';
            cropBox.style.width = startW + 'px'; // ä¿æŒå®½é«˜å›ºå®š
            cropBox.style.height = startH + 'px';
        } 
        else if (isResizing) {
            let newL = startLeft, newT = startTop, newW = startW, newH = startH;

            // æ ¹æ®æ–¹å‘è®¡ç®—
            if (resizeDir.includes('e')) newW = startW + dx;
            if (resizeDir.includes('s')) newH = startH + dy;
            if (resizeDir.includes('w')) {
                newW = startW - dx;
                newL = startLeft + dx;
            }
            if (resizeDir.includes('n')) {
                newH = startH - dy;
                newT = startTop + dy;
            }

            // æœ€å°å°ºå¯¸é™åˆ¶
            if (newW < 20) { newW = 20; if(resizeDir.includes('w')) newL = startLeft + startW - 20; }
            if (newH < 20) { newH = 20; if(resizeDir.includes('n')) newT = startTop + startH - 20; }

            // ç®€å•è¾¹ç•Œæ£€æŸ¥ (é˜²æ­¢åå‘æ‹‰ä¼¸å¯¼è‡´åæ ‡é”™ä¹±)
            if (newL < 0) { newW += newL; newL = 0; }
            if (newT < 0) { newH += newT; newT = 0; }
            if (newL + newW > containerW) newW = containerW - newL;
            if (newT + newH > containerH) newH = containerH - newT;

            cropBox.style.left = newL + 'px';
            cropBox.style.top = newT + 'px';
            cropBox.style.width = newW + 'px';
            cropBox.style.height = newH + 'px';
        }
        
        updateMask();
        updateStatus();
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        isResizing = false;
    });

    // æ›´æ–°é®ç½©å±‚å½¢çŠ¶ (åˆ©ç”¨ clip-path)
    function updateMask() {
        const l = cropBox.offsetLeft;
        const t = cropBox.offsetTop;
        const w = cropBox.offsetWidth;
        const h = cropBox.offsetHeight;
        const cw = imgContainer.offsetWidth;
        const ch = imgContainer.offsetHeight;

        // ç”Ÿæˆåå‘é®ç½©çš„ clip-path æ˜¯æ¯”è¾ƒéº»çƒ¦çš„ï¼Œè¿™é‡Œç”¨ç®€å•çš„ CSS border æ¨¡æ‹Ÿï¼Ÿ
        // æˆ–è€…ç›´æ¥ä¸ç®¡é®ç½©ï¼Œåªé«˜äº®é€‰åŒºã€‚
        // ä¸ºäº†ç®€å•æœ‰æ•ˆï¼Œæˆ‘ä»¬ç”¨ 4ä¸ª div æ‹¼é®ç½©ï¼Œæˆ–è€… svgï¼Œæˆ–è€…æ›´ç®€å•çš„ï¼š
        // å®é™…ä¸Š overlayMask ç”¨ CSS clip-path æœ€ä¼˜é›…ï¼š
        overlayMask.style.clipPath = `polygon(
            0% 0%, 0% 100%, ${l}px 100%, ${l}px ${t}px, 
            ${l+w}px ${t}px, ${l+w}px ${t+h}px, ${l}px ${t+h}px, ${l}px 100%, 
            100% 100%, 100% 0%
        )`;
    }

    // è·å–é€‰åŒºåœ¨åŸå§‹å›¾ç‰‡ä¸­çš„çœŸå®åæ ‡
    function getCropRectNatural() {
        const cw = imgContainer.offsetWidth;
        const ch = imgContainer.offsetHeight;
        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ (é¡µé¢æ˜¾ç¤ºå¤§å° / åŸå§‹å¤§å°)
        // æ³¨æ„ï¼šobject-fit: contain å¯èƒ½ä¼šå¯¼è‡´å›¾ç‰‡å®é™…æ˜¾ç¤ºåŒºåŸŸå°äº img æ ‡ç­¾åŒºåŸŸï¼Œ
        // ä½†è¿™é‡Œæˆ‘ä»¬è®© #sourceImg display:block ä¸” max-widthï¼Œå®ƒæ˜¯æ’‘å¼€å®¹å™¨çš„ï¼Œ
        // æ‰€ä»¥ container çš„å®½é«˜å°±æ˜¯å›¾ç‰‡çš„æ˜¾ç¤ºå®½é«˜ã€‚
        const scale = naturalW / cw; // 1ä¸ªæ˜¾ç¤ºåƒç´  = scale ä¸ªçœŸå®åƒç´ 

        return {
            x: cropBox.offsetLeft * scale,
            y: cropBox.offsetTop * scale,
            w: cropBox.offsetWidth * scale,
            h: cropBox.offsetHeight * scale
        };
    }

    // 3. è£å‰ªä¸‹è½½é€»è¾‘
    downloadBtn.addEventListener('click', async () => {
        statusInfo.textContent = "æ­£åœ¨å¤„ç†...";
        
        const zip = new JSZip();
        const folder = zip.folder("cut_emojis");
        const cols = parseInt(colsInput.value);
        const rows = parseInt(rowsInput.value);
        const rect = getCropRectNatural();
        
        // è®¡ç®—æ¯ä¸ªæ ¼å­çš„çœŸå®æºå®½é«˜
        const srcCellW = rect.w / cols;
        const srcCellH = rect.h / rows;

        // ç¡®å®šè¾“å‡ºå®½é«˜
        let destW = srcCellW;
        let destH = srcCellH;

        if (resizeCheck.checked) {
            destW = parseInt(document.getElementById('targetW').value);
            destH = parseInt(document.getElementById('targetH').value);
        }

        let count = 0;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                count++;
                const canvas = document.createElement('canvas');
                canvas.width = destW;
                canvas.height = destH;
                const ctx = canvas.getContext('2d');

                // æ ¸å¿ƒï¼šä»æºå›¾ (sourceImg) çš„ (rect.x + c*w, rect.y + r*h) å¤„å‰ªåˆ‡
                ctx.drawImage(
                    sourceImg,
                    rect.x + c * srcCellW, rect.y + r * srcCellH, // æºèµ·ç‚¹
                    srcCellW, srcCellH,                           // æºå®½é«˜
                    0, 0,                                         // ç›®æ ‡èµ·ç‚¹
                    destW, destH                                  // ç›®æ ‡å®½é«˜
                );

                await new Promise(resolve => {
                    canvas.toBlob(blob => {
                        const fname = `emoji_${count.toString().padStart(2, '0')}.png`;
                        folder.file(fname, blob);
                        resolve();
                    }, 'image/png');
                });
            }
        }

        zip.generateAsync({type:"blob"}).then(content => {
            saveAs(content, "custom_emojis.zip");
            statusInfo.textContent = "æ‰“åŒ…å®Œæˆï¼";
        });
    });

</script>
</body>
</html>
